# Инструкция по запуску тестов.

Помимо тестов на корректные выходные данные система автотестирования будет
проверять вашу программу и ее исходный код по следующим пунктам:

* **Стилевые тесты.** Чтобы проверить, насколько красота вашего кода соответствует
  стандартам, вы можете протестировать ваш код с помощью утилиты _clang-format_. В папке ```materials/linters``` лежит файл ```.clang-format```, который содержит необходимые настройки для стилевого теста. Данный конфигурационный файл распространяет свое действие на все файлы, которые лежат с ним в директории или в директориях ниже. Поэтому, чтобы данные настройки применились к вашим файлам с исходным кодом, скопируйте ```.clang-format``` в папку src. \
  \
  Чтобы запустить проверку на стиль, выполните следующую команду: \
  ```clang-format -n src/sourcefile_name.c``` 

  Необходимая версия clang-format: \
  **Mac** 14.0.5 \
  **Linux** 13.0.1

* **Тест на корректную работу с памятью.** При написании C-программ очень важно следить за утечками памяти. Для этого в Unix-подобных операционных системах довольно часто используют утилиту _valgrind_. Однако, на OS X имеются проблемы с поддержкой valgrind, поэтому вместо нее можно использовать утилиту _leaks_. Вдаваться в механизм работы этих утилит мы сейчас не будем - если интересно, можете почитать в гугле.
  
 #### _LEAKS (для MacOS)_

  **Важно!** Если вы используете Unix-подобную систему (например, Ubuntu / Linux Mint / Debian), перейдите в пункт с [инструкцией по использованию VALGRIND](#valgrind-для-ubuntu--linux-mint--debian).

  Чтобы запустить ваш исполняемый файл с помощью этой утилиты, наберите в терминале: \
  ```leaks -atExit -- ./main.out | grep LEAK:```
  
  Обратите внимание на команду ```| grep LEAK:```. Мы используем ее для короткого вывода, чтобы видеть только линии с утечками, если они есть. Если вы хотите увидеть весь вывод, просто удалите эту команду. 

  При запуске исполняемого файла с помощью _leaks_ может появиться сообщение об ошибке:
  >dyld: could not load inserted library ‘/usr/local/lib/libLeaksAtExit.dylib’ because image not found
  
  Ошибка возникает из-за того, что _leaks_ не может найти библиотеку _libLeaksAtExit.dylib_. \
  В этом случае вам необходимо ввести следующие команды:
  ```sh
  cd /usr/local/lib  
  sudo ln -s /Applications/Xcode.app/Contents/Developer/usr/lib/libLeaksAtExit.dylib
  ```

  _Дополнительно:_ \
  Используйте флаг ```-exclude``` утилиты _leaks_ для того, чтобы отфильтровать утечки в функциях, где известно об утечках памяти. Этот флаг позволяет уменьшить количество посторонней информации, сообщаемой _leaks_.

  ---

  #### _VALGRIND (для Ubuntu / Linux Mint / Debian)_
  
  Чтобы запустить ваш исполняемый файл с помощью этой утилиты, наберите в терминале: \
  ```valgrind --tool=memcheck --leak-check=yes  ./main.out```

  Не рекомендуется использовать _valgrind_ на OS X, вместо нее лучше использовать [_leaks_](#leaks-для-macos).

  Также, вы можете ознакомиться с [информацией по установке софта и Valgrind](https://21-school.ru/install_soft_to_school_IMacs).
  
  ---

* **Статический анализ кода.** Иногда (или не совсем иногда) встречается такое, что
  корректно компилирующаяся C-программа работает совершенно неправильно или завершается
  с ошибкой попытки доступа не к своей области памяти. Чтобы предотвратить подобные
  ошибки на этапе написания программы, используют специальные утилиты, которые анализируют
  ваш исходный код на предмет потенциальных ошибок. Наша система автотестов использует
  для этого ```cppcheck```.

  Вы можете протестировать ваш исходный код: \
  ```cppcheck --enable=all --suppress=missingIncludeSystem src/soursefile_name.c``` \
  Также можно проверить сразу все файлы с исходным кодом в директории: \
  ```cppcheck --enable=all --suppress=missingIncludeSystem src/```

  Необходимая версия cppcheck: \
  **Mac** 2.8 \
  **Linux** 2.8

  **Доп. проверки на корректную работу с памятью.** Как еще один вариант проверки корректности работы с памятью и отслеживания утечек памяти - использование утилиты AddressSanitizer, встроенной в gcc. Отметим сразу, что ее стоит использовать отдельно от leaks или valgrind, т.к. она автоматически встраивается в бинарный файл после компиляции и может конфликтовать с этими утилитами.

  Для ее использования при компиляции указываем флаг `-fsanitize=address`. Например:
  ```
  gcc -o main main.c -fsanitize=address
  ```
  И запускаем собранную программу обычным образом. В таком случае, если есть какие-то ошибки связанные с памятью - они будут выведены в консоль.

  Помимо флага `-fsanitize=address`, можно также использовать следующие флаги:
  * `-fsanitize=leak` - для отслеживания утечек памяти. Но не забывайте также дополнительно проверить утечки при помощи leaks или valgrind.
  * `-fsanitize=undefined` - для обнаружения мест неопределенного поведения программы (например, выход за границы массива или переполнение int'а).
  * `-fsanitize=unreachable` - для обнаружения недостижимых точек программы.

  Больше флагов вы можете найти в документации gcc и AddressSanitizer'а.
